apply plugin: 'co.riiid.gradle'
apply plugin: 'idea'

project.ext {
  stagingDirName = 'webpiecesServerBuilder'
  outputStagingDir = new File(buildDir, stagingDirName)
}

project('webpiecesServerBuilder:templateProject:WEBPIECESxAPPNAME') {

    sourceSets {
        main {
            resources {
                srcDirs += ["src/main/java"]
                excludes = ["logback.xml"]
            }
        }
    }

    //Intellij Idea has a weird quirk we need to avoid
    if (System.getProperty('idea.active')) {

        // to have classes and resources in the same output directory
        idea {
            module {
                outputDir file("out/production/classes")
            }
        }
    }

    dependencies {
        compile project(':webserver:http-webserver')
        //we start people off with the hibernate plugin 
        compile project(':webserver-plugins:plugin-hibernate')
        compile project(':webserver-plugins:plugin-json-jackson')
        compile project(':webserver-plugins:plugin-backend')
        compile project(':webserver-plugins:plugin-install-sslcert')
        compile deps['commons-lang'] //used in json escaping
		
        testCompile project(':core:core-ddl')
        testCompile project(':core:core-mock')
        testCompile project(':webserver-plugins:plugin-h2db')
        testCompile project(':webserver:http-webserver-test')
        testCompile deps['selenium']
    }

    //task uploadArchives(overwrite: true) << {
    //}

    //ok, this is the deal here.  JPA/hibernate made the decision to look for a persistence.xml file
    //and scan for classes with @Entity in the directory OR jar with that xml file only
    //maven(and I hate this) a long time ago separated src/main/java and src/main/resources but
    //this screws tools in many situations like this one so this puts it back so the output is at
    //least put to the same location
    sourceSets.main.output.resourcesDir = sourceSets.main.output.classesDir
    compileJava.doLast {
       //tasks.processResources.execute()
       logger.warn("processed resources="+sourceSets.main.output.resourcesDir)
    }

    test {
        if (project.hasProperty('excludeSelenium')) {
            exclude '**/*Selenium*'
        }
    }
}

project('webpiecesServerBuilder:templateProject:WEBPIECESxAPPNAME-dev') {
    dependencies {
        compile project(':webserver:http-webserver')
        compile project(':webserver:http-router-dev')
        compile project(':webserver:http-templating-dev')
        compile project(':webserver:webpiecesServerBuilder:templateProject:WEBPIECESxAPPNAME')

        //we start people off with h2 plugin in dev mode that they can delete later if they want(easier to delete then to setup)
        //h2 works well for in-memory testing if using jdbc.  if using nosql, just delete this and code that no longer compiles after that
        compile project(':webserver-plugins:plugin-h2db')
    }
    
    //task uploadArchives(overwrite: true) << {
    //}
}

//Workaround until https://issues.gradle.org/browse/GRADLE-1883 is better from
//http://stackoverflow.com/questions/29504250/how-to-copy-hidden-resource-files-in-gradle
org.apache.tools.ant.DirectoryScanner.removeDefaultExclude("**/.gitignore")

task stageTemplate(type: Copy) {
    from '.'
    into buildDir
    include stagingDirName + '/**'
    include stagingDirName + '/.gitignore'
    exclude stagingDirName + '/output'
    exclude stagingDirName + '/.classpath'
    exclude stagingDirName + '/.project'
    exclude stagingDirName + '/.settings'
    exclude stagingDirName + '/build.gradle.template'
    exclude stagingDirName + '/templateProject/bin'
    exclude stagingDirName + '/templateProject/.classpath'
    exclude stagingDirName + '/templateProject/.project'
    exclude stagingDirName + '/templateProject/.settings'
    exclude stagingDirName + '/templateProject/output'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/output'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/out'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/bin'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/eclipse-output'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/.classpath'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/.project'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME/.settings'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/output'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/out'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/bin'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/eclipse-output'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/.classpath'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/.project'
    exclude stagingDirName + '/templateProject/WEBPIECESxAPPNAME-dev/.settings'
}

task copyGradleTemplate(type: Copy, dependsOn: 'stageTemplate') {
    from stagingDirName
    into outputStagingDir
    include 'build.gradle.template'
    rename { file -> 'build.gradle' }
    expand(version: version, title: 'ProjectInfo')
    outputs.upToDateWhen { false }
}

task zipGradleTemplate(type: Zip, dependsOn: 'copyGradleTemplate') {
   from buildDir
   include stagingDirName + "/**"
   baseName stagingDirName
}

assemble.dependsOn(['zipGradleTemplate'])

//task uploadArchives(overwrite: true, dependsOn: 'build') << {
//}

if(project.hasProperty('projVersion')) {
    github {
        owner = 'deanhiller'
        repo = 'webpieces'
        token = githubToken
        tagName = version
        name = 'webpiecesServerBuilder'+version
        body = 'Official Release of '+version
        assets = [
            zipGradleTemplate.archivePath
        ]
    }

    githubRelease.dependsOn([':webserver:build', ':promoteRepository'])
    githubRelease {
        doFirst {
            println("releasing to github="+github.assets)
        }
    }
} else {
    task githubRelease(overwrite:true, dependsOn: [':webserver:build', ':uploadArchives2'])
}
