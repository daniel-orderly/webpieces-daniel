#{extends '../backend/main.html'/}#
#{set title:'Controllers'/}#
#{set tab:'management'/}#

#{renderTagArgs 'docHome.html'/}#

<ol>
   <li><a href="#controller">Singleton Controller</a></li>
   <li><a href="#actions">Actions</a></li>
   <li><a href="#validation">Validation</a></li>
   <li><a href="#sessionScope">Session Scope</a></li>
   <li><a href="#flashScope">Flash Scope</a></li>   
   <li><a href="#tabScope">Browser Tab Scope</a></li>
   <li><a href="#requestCtx">Request Context</a></li>
   <li><a href="#annotation">@UserQuery Annotation</a></li>
   <li><a href="#routerRequest">Asynchronous Methods</a></li>
   <li><a href="#routerRequest">RouterRequest</a></li>
   <li><a href="#overrides">Overriding HttpResponse Headers</a></li>
</ol>

<h3 id="controller">Singleton Controller</h3>

<p>You will notice very quickly if you have not already that webpieces forces all your Controllers to have the
@Singleton annotation.  We believe in a stateless server meaning only one instance of the Controller is necessary
plus it saves on performance so we don't have to construct it every time like J2EE sometimes does which is
a pure waste of resources in a ton of cases where you are stateless anyways.</p>

<h3 id="actions">Actions</h3>

<p>Every Controller method returns some sort of Action where the type heirarchy looks like so</p>

<ol>
    <li>Action
    <ol>
        <li>AjaxRedirect</li>
        <li>Redirect</li>
        <li>Render</li>
    </ol>
    </li>
</ol>

<p>This means your Controller must return one of these types.  If you are a post method, then you must always return
a Redirect and webpieces will complain to you if you don't.  All Actions are created via the Actions.java class.  A
typical GET method in a controller looks like so:</p>

<pre><code>*[public Render easyUpgrade() {
    return Actions.renderThis("menu", menuCreator.getMenu());
}]*</code></pre>

<p>Notice that I could change the return type to Action if the GET method does a Redirect or a Render like so:</p>

<pre><code>*[public Action easyUpgrade() {
    if(something)
        return Actions.redirect(MyRouteId.LOGIN);
    return Actions.renderThis("menu", menuCreator.getMenu());
}]*</code></pre>

<p>A POST method which is forced into returning a redirect to be compliant with PRG may look like so:</p>

<pre><code>*[public Redirect postDeleteUser(int id) {
	UserDbo ref = Em.get().find(UserDbo.class, id);
	Em.get().remove(ref);
	Em.get().flush();
	Current.flash().setMessage("User deleted");
	Current.flash().keep();
	return Actions.redirect(CrudUserRouteId.LIST_USERS);
}]*</code></pre>

<p>Now, AjaxRedirect created by Actions.ajaxRedirect is a special case.  Because you can't return http code 303 Redirect to
javascript components as they will then redirect internally and load that html, they need to be told the server wants you 
to redirect to some page.  This is where AjaxRedirect comes into play.  He is translated to a http 287 code so your javascript
can check for this code and redirect on the javascript side. </p>

<p>AjaxRedirect is wired into some common components already such that it will redirect when necessary</p>

<h3 id="validation">Validation</h3>

<p>In typical api development, you typically want to KISS and send errors back on the first issue you find with a request.
In GUIs however, you want to give a phenomenal user experience and give as many correctable errors as you can in the
first go.  For this reason there is a validation like so:</p>

<pre><code>*[if(password == null) {
    Current.validation().addError("password", "password is required");
}

if(entity.getFirstName() == null) {
    Current.validation().addError("entity.firstName", "First name is required");
}]*</code></pre>

<p>Finally, once you have an added an error to each field, you can check if there are any errors to
display a global message or global error:</p>

<pre><code>*[if(Current.validation().hasErrors()) {
	Current.flash().setMessage("You have errors below");
	Current.flash().setError("You have errors below");
}]*</code></pre>

<p>But 'wait' you say, why in the world is there 2 ways of setting a message or error.  Good question!  
Typically, you will have something like this in your template that is at the top of every page:</p>

<pre><code>*[#{if _flash.message}#
    <div class="row-fluid">
        <div class="offset3 span6 alert alert-error">
            ${_flash.message}$
        </div>
    </div>
#{/if}#]*</code></pre>

<p>This reads from the message and so if you are doing basic boring straight up html, you can use the 
message inside the flash scope for any previous page to display a 1 time message like 'User Successfully Saved'
or 'You have errors in your form below'.<p>

<p>If however you are doing AJAX add/edit popup, the message is on the main page so instead in your ajax
add/edit popup, you may have code like this to read the global error:</p>

<pre><code>*[#{if _flash.error}#
<div class="row-fluid">
    <div class="offset3 span6 alert alert-error">
        <h4>Oops....</h4>
        ${_flash.error}$
    </div>
</div>
#{/if}#]*</code></pre>

<p>Now, let's look at adding an error to an entity.  In this next example, we are adding an error
to 'entity.firstName':</p>

<pre><code>*[Current.validation().addError("entity.firstName", "First name is required");]*</code></pre>

<p>Now, in our page, we can access the error like so:</p>
 
<pre><code>*[_ctx.validation.getError('entity.firstName')]*</code></pre>

<p>Instead, however, we have created the field tag which is used like so:</p>

<pre><code>*[#{field 'entity.firstName', label:'First Name'}#<input type="text" name="${field.name}$" value="${field.flashOrValue}$" class="input-xlarge">#{/field}#]*</code></pre>

<p>and thankfully FieldTag.java sets up a Map variable called 'field' so that the actual field.tag file can use
a variable *[${field.error}$]*:</p>

<pre><code>*[<span id="${field.id}$_errorMsg" class="help-block">${field.error}$</span>]*</code></pre> 

<p>As a final note, the validation bean is a flash scoped cookie held by the browser.  When you set something
on the validation bean, a cookie is sent to your browser with the redirect(remember we force posts to
send a redirect) and then the browser sends a GET with your validation cookie, we render the page and
then unless you call validation.keep(), we clear out the validation bean.  This is done after the html
is rendered though so your html has time to use the error messages in the page.</p>

<h3 id="sessionScope">Session Scope</h3>

<p>You can access the session like so</p>

<pre><code>*[Current.session().put("key", "something");
Current.session().remove("key");
Current.session().get("key");
]*</code></pre>

<p>Whatever you put in the session stays there until you remove it.  The session is secured with a message digest hash
that is compared every time webpieces receives a request.  If it is invalid, we reject and clear their cookie completely
assuming it is either a hacker or a bug.</p>

<p>To access the session from the html, you can do something like this:</p>

<pre><code>*[#{if _session.get('userId')}#
    <li>
        <div>Logged In User: ${_session.get('userId')}$</div>
    </li>
#{/if}#]*</code></pre>

<p>However, let's say you are booking plane tickets in two different tabs.  Session is definitely not where
you want to be saving the user experience.  For that situation, you would want to save it into some sort of
tab state.  Of course, for some reason, the larger community has not created a spec for a tab cookie that
only goes back and forth for one single tab in a browser :( so tab state has to be simulated within
the url query params.</p> 

<h3 id="flashScope">Flash Scope</h3>

<p>Flash can be accessed like so in a java controller:</p>

<pre><code>*[Current.flash().put("someKey", "someValue");
Current.flash().setMessage("User successfully saved");
Current.flash().keep();]*</code></pre>
        
<p>setMessage is a special method that just does the same thing as .put("_message", "User Successfully saved"); so 
another words the _message key is reserved for him.  keep() must be called or none of the state will be saved.  Also,
if you receive a flash data from a previous post and add more data and call keep() yet again, all the previous
data from the previous flash will also be saved over yet again.</p>

<p>In html, you can also access the flash with _flash variable like so:</p>

<pre><code>*[#{if _flash.message}#
    <div class="row-fluid">
        <div class="offset3 span6 alert alert-error">
            ${_flash.message}$
        </div>
    </div>
#{/if}#]*</code></pre>

<p>Or access a specific key like so:</p>

<pre><code>*[${_flash.get('flashData')}$]*</code></pre>

<h3 id="tabScope">Browser Tab Scope</h3>

<b>Does not exist as of yet.  This is to be created</b>

<p>Tab Scope exists so when you have a user that can book tickets in multiple tabs, session scope
would be horrible and would conflict.  Instead Tab Scope exists for ease of developing these 
types of applications</p>

<p>To enable tab scope or from your controller, using something like Current.tabState().get("key")
or from your html, using something like *[${_tab.get('key')}$]*, you need to define when a
conversation name and when a conversation starts and ends</p>

<p>When a conversation starts, we will tack on a conversation name and a tab id(tid) onto 
the end of every url like http://somedomain.com/some/account?tid=conversation1-234.  We will 
also write out a cookie with the conversationName-tid so that every time we receive a 
request with a tid, we can lookup and setup the Current.tabState() for you such that you can use
it</p>  

<p>These cookies can be left dangling and add up so to prevent that, when creating a 
conversation name and when it starts and ends, you also define a timeout for that conversation
and where we will redirect the user when that specific conversationName times out which
can allow them to start over on the conversation</p>

<h3 id="requestCtx">Request Context</h3>

<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>

<h3 id="annotation">@UserQuery Annotation</h3>

<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>

<h3 id="routerRequest">RouterRequest</h3>

<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>

<h3 id="overrides">Overriding HttpResponse Headers</h3>

<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>
<pre><code>*[]*</code></pre>


